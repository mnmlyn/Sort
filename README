排序算法是经典，之前并没有成体系地练习。
现在把这些算法靠自己思考，转化为代码。

包括以下：
冒泡排序BubbleSort


算法思路：
以下讨论默认升序排序。
1.冒泡排序
    假设有n个数，则外层循环共有n-1次。先将最大的数放在n-1位置，再将剩余数中的最大数放在n-2位置，以此类推，
直到剩下两个数，把较大数放在1位置。内层循环，从未排序数中从头开始，两两比较，将较大数交换到后边。
2.选择排序
    和冒泡排序很像。外层循环相同，不同的是内层循环，不是两两比较并总将较大数交换到后边，而是找到（选择出）
最大数，然后交换到目标位置。
3.插入排序
    插入排序和整理扑克牌的方法很像。拿来一个数，将其插入到已经有序的子数组中。
    让数组前边是有序的，记录有序部分的结尾下标。外层循环每次从无序部分取出一个数，内层循环将这个数插入到有
序部分的合适位置。
4.快速排序
    采用递归方式，每次选取一个基准元素，做重排。重排之后，基准左边的元素都不大于基准，右边都大于基准。然后，
对基准左边的部分和右边的部分，分别递归调用排序。
5.堆排序
    堆（默认大顶堆）是一个特殊的数据结构，逻辑上这是一棵完全二叉树，任意一个节点的值都大于其孩子节点的值。
一个堆，有最大容量和当前尺寸两个参数。包含建堆、调整两个基本算法。
    建堆，是从最后一个非叶子节点开始向前，依次将较大元素向上移动。建堆可以调用调整堆。
    调整，是假设传入节点i的左和右两个子树都是符合定义的堆，只有i有可能不符合堆，从而可能需要将i节点向下调整。
    堆排序，是先建堆，然后取出堆顶元素，为找到的最大值，用最后一个元素成为新的堆顶，从而将找到的最大值放在最
后，并且缩减堆的当前尺寸。依次执行这个过程，直到堆的大小为1。
6.归并排序
    采用分治的思想，递归方式。将待排序数组切成前后两半，递归调用归并排序分别对前一半和后一半进行排序，然后对
排序结果进行合并，得到最终排序结果。在合并的时候，为了防止每次都判断是否已经合并完了一个子数组，也就是为了避
免边界条件的判断，可以在子数组最后加一个INT_MAX元素，这是一个不可能越过的边界，从而避免了边界判断。